#include <stdio.h>

#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "cmath"
// Our assembled program:
#include "basic_audio.pio.h"

// This example uses the default led pin
// You can change this by defining HELLO_PIO_LED_PIN to use a different gpio

uint32_t *buffer_adress_pointer; // swap buffers A and B here
uint32_t *buffA;
uint32_t *buffB;
const size_t BUFFSIZE = 2048;

uint ctrl_channel; // the CTRL DMA channel number

const uint64_t SPS = 45045; // samples per second
uint64_t chunkcount = 0;    // tracks the number of samples already generated

const double lpfdt = 1 / double(SPS);
double lpfprev = 0;

bool buffer_flag = false;

void dma_irq_handler()
{
    // check if our interrupt came from the CTRL DMA
    if (dma_channel_get_irq0_status(ctrl_channel))
    {
        dma_channel_acknowledge_irq0(ctrl_channel);
        buffer_flag = true;
    }
}

static inline void hello_program_init(PIO pio, uint sm, uint offset, uint pin)
{
    //PIN SETUP:
    //  DATA: pin
    //  LCK:  pin + 1
    //  BCK:  pin + 2
    
    // get the base configuration from the default config generated by the assembler
    pio_sm_config c = basic_audio_program_get_default_config(offset);
    /* -----STATE MACHINE CONFIG------
        -setup clock division
        -setup which pin is out
        -setup sideset pin
        -shift direction
        etc..
    */
    // sm_config_set_clkdiv(&c, 500);
    /*
        We set the clkdiv to 13 so we have 45 kHz sample rate
        We set the main pins and the sideset pins
        We use shift left on the OSR of the pio for MSB first
        We configure wrap and autopull, the PIO will automatically wrap and PULL new data into the OSR
    */
    sm_config_set_clkdiv_int_frac8(&c, 13, 1); // setting up clock divisor
    sm_config_set_out_pins(&c, pin, 1);        // maps the base out pin + pin count to our chosen pin
    sm_config_set_sideset_pins(&c, pin + 1);   // set the sideset pin base, automatically grabs enough pins
    sm_config_set_out_shift(&c, false, true, 32);
    // sm_config_set_fifo_join(&c,PIO_FIFO_JOIN_TX);
    sm_config_set_wrap(&c, offset + basic_audio_wrap_target, offset + basic_audio_wrap);

    /* -------INIT PINS------
        call pio_gpio_init() on each pin
        set the pin directions using pio_sm_set_consecutive_pindirs()
    */
    pio_gpio_init(pio, pin);
    pio_gpio_init(pio, pin + 1);
    pio_gpio_init(pio, pin + 2);
    // Set the pin direction for all three pins to output
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 3, true);

    //-----INIT PIO-----
    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running with pio_sm_set_enabled()
    // pio_sm_set_enabled(pio, sm, true);
}

inline uint32_t int16_to_uint32(int16_t i)
{
    return i << 16;
}


void init_buffers()
{
    buffA = new uint32_t[BUFFSIZE];
    buffB = new uint32_t[BUFFSIZE];
    for (size_t i = 0; i < BUFFSIZE; i++)
    {
        buffA[i] = 0;
        buffB[i] = 0;
    }
}

// takes a dma channel that is specified with a uint
void arm_dma_chained(PIO pio, uint sm, uint dma_channel, uint dma_ctrl_channel, uint32_t *buffer, uint32_t transfer_count)
{
    /*----------------DMA SETUP-------------------
    We setu up two DMA channels
      1) for moving our audio buffer into the PIO
      2) for moving the adress of the current buffer into th
        the first DMA (this also starts it again)

    the control DMA channel must also have an IRQ
    interrupt set up, so that we can know when to swap buffers
    ---------------------------------------------*/

    // first generate default configs for our dma channel
    dma_channel_config c = dma_channel_get_default_config(dma_channel);
    // since we are reading from a buffer, we should increment the position where we read from on each read
    channel_config_set_read_increment(&c, true);
    // however the destination (the PIO TX FIFO) should remain constant
    channel_config_set_write_increment(&c, false);
    // since we are using signed 32bit integers we want to make sure the dma transfers in 32 bit chunks
    channel_config_set_transfer_data_size(&c, DMA_SIZE_32);
    // get a TX DREQ from our PIO, when the FIFO gets emptied it will send a signal to the DMA to fill it
    channel_config_set_dreq(&c, pio_get_dreq(pio, sm, true));

    // sets up the chaining, after dumping the buffer it will trigger the CTRL DMA which loads the buffer start
    // back into the main DMA channel, thus restarting the whole process and triggering an IRQ
    channel_config_set_chain_to(&c, dma_ctrl_channel);

    // now we configure our dma channel
    //   - set the read buffer (it is int32_t since we want to write signed integers)
    //   - set the write address to the PIO TX FIFO
    //   - number of transfers. What is that?
    //   - we later start the DMA using dma_channel_start(channel);
    dma_channel_configure(
        dma_channel,
        &c,
        &pio->txf[sm], // the pio FIFO
        buffer,
        transfer_count,
        false);

    //------CONTROL CHANNEL-----
    dma_channel_config c_ctrl = dma_channel_get_default_config(dma_ctrl_channel);
    // we will read from one place to one place
    channel_config_set_read_increment(&c_ctrl, false);
    channel_config_set_write_increment(&c_ctrl, false);
    channel_config_set_transfer_data_size(&c, DMA_SIZE_32);

    dma_channel_configure(
        dma_ctrl_channel,
        &c_ctrl,
        &dma_hw->ch[dma_channel].al3_read_addr_trig, // the target is the addr_trig, will triger the dma again and set the buffer pointer
        &buffer_adress_pointer,                      //(int32_t **) pointer that contains the address of the start of the buffer
        1,
        false);

    // enable the control channel to send an IRQ interrupt
    dma_channel_set_irq0_enabled(dma_ctrl_channel, true);

    // we will handle the interrupt with our custom function
    irq_set_exclusive_handler(DMA_IRQ_0, dma_irq_handler);
    irq_set_enabled(DMA_IRQ_0, true);
}

//-----------------SOME FUNCTIONS TO GENERATE SOUND----------------------------------------

int16_t clamp(int16_t v, int16_t min, int16_t max)
{
    if (v > max)
    {
        return max;
    }
    else if (v < min)
    {
        return min;
    }
    else
    {
        return v;
    }
}

double clampd(double v, double min, double max)
{
    if (v > max)
    {
        return max;
    }
    else if (v < min)
    {
        return min;
    }
    else
    {
        return v;
    }
}

double lfo_saw(double t, float f, double amplitude)
{
    double cycles = t * f / 2;
    double phase = cycles - floor(cycles);
    double result = (phase * amplitude);
    return result;
}

int16_t saw(double t, float f, int16_t amplitude)
{
    double cycles = t * f / 2;
    double phase = cycles - floor(cycles);
    double result = 2 * (phase * amplitude) - amplitude;
    return (int16_t)result;
}

int16_t sinegen(double t, int amp, double f)
{
    return amp * sin(f * t * M_PI);
}

int16_t lpf(double sample, double cutoff)
{
    double alfa = (2 * M_PI * lpfdt * cutoff) / (2 * M_PI * lpfdt * cutoff + 1);
    double newsample = lpfprev + alfa * (sample - lpfprev);
    lpfprev = newsample;
    return int16_t(newsample);
}

inline int16_t get_sample(double t, uint64_t samp)
{
    const int maxamp = 32767 / 2.5;
    return sinegen(t,maxamp/5,440);
    //uncomment for a simple tune
    /* int16_t sample = saw(t,174,maxamp/3)+saw(t,172,maxamp/3)+saw(t,176,maxamp/3);
    sample = sample + saw(t, 174, maxamp / 3) + saw(t, 172, maxamp / 3) + saw(t, 176, maxamp / 3);
    sample = lpf(sample, 800 - lfo_saw(t, 2, 800));
    sample = sample + lpf(saw(t, 348, maxamp / 2.5), 1200 - lfo_saw(t, 8, 1200));
    return sample;*/
}

void generate_buffer(uint32_t *buffer)
{
    for (size_t i = 0; i < BUFFSIZE - 1; i += 2)
    {
        double t = double(chunkcount + i) / double(SPS); // calculate the elapsed time in seconds
        int16_t val = get_sample(t, chunkcount + i);     // get a new sample
        buffer[i] = int16_to_uint32(val);                // the left audio channel
        buffer[i + 1] = int16_to_uint32(val);            // the right audio channel
    }
    chunkcount = chunkcount + BUFFSIZE;
}

int main()
{
    // first we need to set up variables for our pio
    PIO pio;
    uint sm;
    uint offset;

    // This will find a free pio and state machine for our program and load in our program
    // the hello_program is defined in hello.pio.h, which was autogenerated by the assebler from hello.pio
    // We use pio_claim_free_sm_and_add_program_for_gpio_range so we can address gpios >= 32 if needed and supported by the hardware
    bool success = pio_claim_free_sm_and_add_program_for_gpio_range(&basic_audio_program, &pio, &sm, &offset, 12, 2, true);
    hard_assert(success);

    // configure our PIO
    hello_program_init(pio, sm, offset, 12);

    // we intialize our two buffers to length BUFFLENGTH and fill them with zeros
    init_buffers();

    /*int buffsize = 10000;
    uint32_t* buffer = generate_waveform_buffer_10k();*/
    // we start with buffer B
    buffer_adress_pointer = buffB;

    // we fetch two DMA channels and arm them to be ready to run
    uint dma_channel = dma_claim_unused_channel(true);
    uint dma_ctrl_channel = dma_claim_unused_channel(true);
    ctrl_channel = dma_ctrl_channel;
    arm_dma_chained(pio, sm, dma_channel, dma_ctrl_channel, buffA, BUFFSIZE);

    // we start the DMA channel, since the PIO hasnt been enabled yet, it will prefill its TX FIFO with data
    dma_channel_start(dma_channel);

    // start the PIO, the whole sound generation cascade starts
    pio_sm_set_enabled(pio, sm, true);

    int i = 0;
    while (true)
    {
        if (buffer_flag) // our interrupt has signaled that it began reading a new buffer
        {
            // we swap the buffer_adress_pointer, so when the current buffer runs out, the CTRL DMA will load the other one
            // we also trigger the generation of data into the buffer that was just finished being written from
            if (buffer_adress_pointer == buffB)
            {
                generate_buffer(buffA);
                buffer_adress_pointer = buffA;
            }
            else if (buffer_adress_pointer == buffA)
            {
                generate_buffer(buffB);
                buffer_adress_pointer = buffB;
            }

            buffer_flag = false;
        }
    }
    delete[] buffA;
    delete[] buffB;
    // This will free resources and unload our program
    pio_remove_program_and_unclaim_sm(&basic_audio_program, pio, sm, offset);
}