#pragma once

#include <stdio.h>
#include <array>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"

//the header generated by the PIO assembler containing the assembled program and
//various helper functions for loading the program
#include "audio_device.pio.h"

class AudioDevice;

class IRQHandler
{
private:
    static IRQHandler * instance;

    IRQHandler()
    {
        instance = this;
        n_devices = 0;
    }

    std::array<AudioDevice *,8> devices;

    int n_devices;

    void IRQ_handler_local();
public:

    IRQHandler(IRQHandler &handler_) = delete;

    void operator=(const IRQHandler &hanlder_) = delete;

    static void IRQ_handler_static()
    {
        instance->IRQ_handler_local();
    }

    static IRQHandler * getIRQHandler()
    {
        if (instance == nullptr)
        {
            return new IRQHandler();
        }
        return instance;
    }

    void registerDevice(AudioDevice * device)
    {
        if (n_devices < 8)
        {
            devices[n_devices] = device;
            n_devices++;
        }
    }

};

IRQHandler * IRQHandler::instance = nullptr;

class AudioDevice
{
private:
    //----------HARDWARE DATA--------------

    struct Pins
    {
        uint data;
        uint lck;
        //bck is lck+1
    };
    Pins pins;
    
    //we will have 1 PIO per device
    struct PIOdata
    {
        PIO pio;
        uint sm;
        uint offset;
    };
    PIOdata pio;
    
    //dma channel numbers
    uint dma_channel_buffer;
    uint dma_channel_control;

    //-----------------------------------
    //--------AUDIO BUFFERS AND CONTROLS---
    static const size_t BUFFSIZE = 2048;
    struct Buffer
    {
        uint32_t A[BUFFSIZE];
        uint32_t B[BUFFSIZE];
    };

    Buffer buffer;
    uint32_t *buffer_start_pointer; //we will provide this to the DMA

    bool buffer_update_flag = false;

    uint64_t chunkcount = 0; //number of audio buffers outputted from this device

    const uint64_t SPS = 45045;

    //------------INTERRUPT HANDLER---------
    IRQHandler * IRQ_handler_ptr;

public: //public types
    enum class DeviceMode {
        MONO,
        STEREO
    };

    enum class ChannelMode {
        MONO,
        LEFT,
        RIGHT
    };

    struct ChannelInfo
    {
        uint channel_num;
        ChannelMode chmode;
        uint64_t chunk;
        uint64_t sample;
        uint64_t SPS;
    };

private:
    //channel setup
    DeviceMode mode;
    //virtual channels
    uint channel_num;

//---------PRIVATE FUNCTIONS------------
    //init functions
    inline void audio_device_program_init();
    inline void arm_dma_channels_chained_irq();
    void init_buffers();

    //audio generation
    void generate_buffer();

    //utility

    inline uint32_t int16_to_uint32(int16_t val){
        return val << 16;
    }

public: //public methods
    AudioDevice();
    AudioDevice(uint dataPin, uint lckPin, DeviceMode mode_, uint channels, IRQHandler * irq_h_ptr);
    ~AudioDevice();

    //factory functions
    static AudioDevice createAudioDevice(uint dataPin, uint lckPin, DeviceMode mode, uint channels);

    //public init, returns true uppon successful initialization
    bool initialize();

    //update audio device, returns true if an update has been performed
    bool update();

    bool confirm_interrupt();
};

void IRQHandler::IRQ_handler_local()
{
    for (size_t i = 0; i < n_devices; i++)
    {
        if (devices[i]->confirm_interrupt())
        {
            break;
        }
    }
}

int16_t sample_callback(const AudioDevice::ChannelInfo &info);

inline void AudioDevice::audio_device_program_init()
{
    pio_sm_config c = audio_device_program_get_default_config(pio.offset);

    sm_config_set_clkdiv_int_frac8(&c, 13, 1); // setting up clock divisor
    sm_config_set_out_pins(&c, pins.data, 1);        // maps the base out pin + pin count to our chosen pin
    sm_config_set_sideset_pins(&c,  pins.lck);   // set the sideset pin base, automatically grabs enough pins
    sm_config_set_out_shift(&c, false, true, 32);
    sm_config_set_wrap(&c,pio.offset + audio_device_wrap_target, pio.offset + audio_device_wrap);

    pio_gpio_init(pio.pio, pins.data);
    pio_gpio_init(pio.pio, pins.lck);
    pio_gpio_init(pio.pio, pins.lck + 1);

    pio_sm_set_out_pins(pio.pio,pio.sm,pins.data,1);

    pio_sm_set_consecutive_pindirs(pio.pio,pio.sm, pins.data,1, true);
    pio_sm_set_consecutive_pindirs(pio.pio,pio.sm, pins.lck ,2, true);

    pio_sm_init(pio.pio, pio.sm, pio.offset, &c);
}

inline void AudioDevice::arm_dma_channels_chained_irq()
{
    dma_channel_config c_buffer = dma_channel_get_default_config(dma_channel_buffer);

    channel_config_set_read_increment(&c_buffer, true);
    channel_config_set_write_increment(&c_buffer, false);
    channel_config_set_transfer_data_size(&c_buffer, DMA_SIZE_32);
    channel_config_set_dreq(&c_buffer, pio_get_dreq(pio.pio, pio.sm, true));

    channel_config_set_chain_to(&c_buffer, dma_channel_control);

    dma_channel_configure(
        dma_channel_buffer,
        &c_buffer,
        &pio.pio->txf[pio.sm],
        buffer.A,
        BUFFSIZE,
        false
    );

    dma_channel_config c_ctrl = dma_channel_get_default_config(dma_channel_control);

    channel_config_set_read_increment(&c_ctrl, false);
    channel_config_set_write_increment(&c_ctrl, false);
    channel_config_set_transfer_data_size(&c_ctrl, DMA_SIZE_32);

    dma_channel_configure(
        dma_channel_control,
        &c_ctrl,
        &dma_hw->ch[dma_channel_buffer].al3_read_addr_trig,
        &buffer_start_pointer,
        1,
        false
    );

    dma_channel_set_irq0_enabled(dma_channel_control, true);

    irq_set_exclusive_handler(DMA_IRQ_0, IRQHandler::IRQ_handler_static);
    irq_set_enabled(DMA_IRQ_0, true);

}

inline void AudioDevice::init_buffers()
{
    for (size_t i = 0; i < BUFFSIZE; i++)
    {
        buffer.A[i] = 0;
        buffer.B[i] = 0;
    }
    
}

inline void AudioDevice::generate_buffer()
{
    if (mode == DeviceMode::MONO)
    {
        for (size_t i = 0; i < BUFFSIZE ; i += 2)
        {
            int16_t val = sample_callback(ChannelInfo{0,ChannelMode::MONO,chunkcount+1,i,SPS});
            buffer_start_pointer[i] = int16_to_uint32(val);
            buffer_start_pointer[i + 1] = int16_to_uint32(val);
        }
    }
    else
    {
        for (size_t i = 0; i < BUFFSIZE ; i += 2)
        {
            int16_t valL = sample_callback(ChannelInfo{0, ChannelMode::LEFT, chunkcount + 1, i,SPS});
            int16_t valR = sample_callback(ChannelInfo{1, ChannelMode::RIGHT, chunkcount + 1, i,SPS});
            buffer_start_pointer[i] = int16_to_uint32(valL);
            buffer_start_pointer[i + 1] = int16_to_uint32(valR);
        }   
    }
    chunkcount = chunkcount + 1;
    
}

AudioDevice::AudioDevice()
{

}

inline AudioDevice::AudioDevice(uint dataPin, uint lckPin, DeviceMode mode_, uint channels, IRQHandler * irq_h_ptr)
{
    pins.data       =   dataPin;
    pins.lck        =    lckPin;
    mode            =     mode_;
    channel_num     =  channels;
    IRQ_handler_ptr = irq_h_ptr;
    
    IRQ_handler_ptr->registerDevice(this);
}

AudioDevice::~AudioDevice()
{

}

inline AudioDevice AudioDevice::createAudioDevice(uint dataPin, uint lckPin, DeviceMode mode, uint channels)
{
    return AudioDevice();
}

inline bool AudioDevice::initialize()
{
    if(!pio_claim_free_sm_and_add_program(
            &audio_device_program,
            &pio.pio,
            &pio.sm,
            &pio.offset
        ))
    {
        return false;
    }

    audio_device_program_init();

    init_buffers();

    //the DMA will start reading from buffer A, so we prepare buffer B
    buffer_start_pointer = buffer.B;

    dma_channel_buffer  = dma_claim_unused_channel(false);
    dma_channel_control = dma_claim_unused_channel(false);
    
    if (dma_channel_buffer == -1 || dma_channel_control == -1)
    {
        return false;
    }

    arm_dma_channels_chained_irq();

    dma_channel_start(dma_channel_buffer);

    pio_sm_set_enabled(pio.pio ,pio.sm ,true);

    return true;
}

inline bool AudioDevice::update()
{
    if (buffer_update_flag)
    {
        if (buffer_start_pointer == buffer.B)
        {
            buffer_start_pointer = buffer.A;
        }
        else if (buffer_start_pointer == buffer.A)
        {
            buffer_start_pointer = buffer.B;
        }
        
        generate_buffer();

        buffer_update_flag = false;
        
        return true;
    }
    return false;
}

inline bool AudioDevice::confirm_interrupt()
{
    if (dma_channel_get_irq0_status(dma_channel_control))
    {
        dma_channel_acknowledge_irq0(dma_channel_control);
        buffer_update_flag = true;
        return true;
    }
    return false;
}
