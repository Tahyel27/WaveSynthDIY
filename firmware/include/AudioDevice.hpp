#pragma once

#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"

//the header generated by the PIO assembler containing the assembled program and
//various helper functions for loading the program
#include "audio_device.pio.h"

class AudioDevice
{
private:
    //----------HARDWARE DATA--------------
    struct Pins
    {
        uint data;
        uint lck;
        //bck is lck+1
    };
    
    //we will have 1 PIO per device
    struct PIOdata
    {
        PIO pio;
        uint sm;
        uint offset;
    };
    PIOdata pio;
    
    //dma channel numbers
    uint dma_channel_buffer;
    uint dma_channel_control;

    //-----------------------------------
    //--------AUDIO BUFFERS AND CONTROLS---
    static const size_t BUFFSIZE = 2048;
    struct Buffer
    {
        uint32_t A[BUFFSIZE];
        uint32_t B[BUFFSIZE];
    };

    Buffer buffer;
    uint32_t *buffer_start_pointer; //we will provide this to the DMA

    uint64_t chunkcount = 0; //number of audio buffers outputted from this device

    const uint64_t SPS = 45045;

public: //public types
    enum class DeviceMode {
        MONO,
        STEREO
    };

    enum class ChannelMode {
        MONO,
        LEFT,
        RIGHT
    };

    struct ChannelInfo
    {
        uint channel_num;
        ChannelMode mode;
        uint64_t chunk;
        uint64_t sample;
    };
private:
    DeviceMode mode;

//---------PRIVATE FUNCTIONS------------
    //init functions
    inline void audio_device_program_init();
    inline void arm_dma_channels_chained_irq();

    //audio generation
    void generate_buffer();

public: //public methods
    AudioDevice();
    AudioDevice(uint dataPin, uint lckPin, DeviceMode mode, uint channels);
    ~AudioDevice();

    //factory functions
    static AudioDevice createAudioDevice(uint dataPin, uint lckPin, DeviceMode mode, uint channels);

    //public init, returns true uppon successful initialization
    bool initialize();

    //update audio device, returns true if an update has been performed
    bool update();
};

int16_t sample_callback(AudioDevice::ChannelInfo info);

inline void AudioDevice::audio_device_program_init()
{

}

inline void AudioDevice::arm_dma_channels_chained_irq()
{
    
}

inline void AudioDevice::generate_buffer()
{
}

AudioDevice::AudioDevice(/* args */)
{

}

inline AudioDevice::AudioDevice(uint dataPin, uint lckPin, DeviceMode mode, uint channels)
{
    
}

AudioDevice::~AudioDevice()
{

}

inline AudioDevice AudioDevice::createAudioDevice(uint dataPin, uint lckPin, DeviceMode mode, uint channels)
{
    return AudioDevice();
}

inline bool AudioDevice::initialize()
{
    return false;
}

inline bool AudioDevice::update()
{
    return false;
}
